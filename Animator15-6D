--//====================================================\\--
--||           Animator6D Pro V6.1 (Universal)         ||--
--||        Fixed Version - Proper Pose Handling       ||--
--\\====================================================//--

if getgenv().Animator6DLoadedPro then return end
getgenv().Animator6DLoadedPro = true

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hum = character:WaitForChild("Humanoid")

-- ========== RIG TYPE DETECTION ==========
local function GetRigType()
    if hum.RigType == Enum.HumanoidRigType.R6 then
        return "R6"
    elseif hum.RigType == Enum.HumanoidRigType.R15 then
        return "R15"
    end
    if character:FindFirstChild("UpperTorso") then
        return "R15"
    else
        return "R6"
    end
end

local RIG_TYPE = GetRigType()
warn("[Animator6D] Detected rig type:", RIG_TYPE)

-- ========== LOCAL CACHE / 403 EVASION ==========
local LocalAssetCache = {}
local fullModel = nil
pcall(function()
    fullModel = game:GetObjects("rbxassetid://107495486817639")[1]
    if fullModel then
        fullModel.Parent = workspace
    end
end)

local function LoadLocalAsset(id)
    id = tostring(id):gsub("^rbxassetid://", "")
    if LocalAssetCache[id] then
        return LocalAssetCache[id]
    end

    local found = fullModel and fullModel:FindFirstChild(id, true)
    if found then
        LocalAssetCache[id] = found
        warn("[Animator6D] ✅ Loaded from local cache:", id)
        return found
    end

    local ok, obj = pcall(function()
        return game:GetObjects("rbxassetid://" .. id)[1]
    end)
    if ok and obj then
        LocalAssetCache[id] = obj
        warn("[Animator6D] ✅ Loaded via GetObjects:", id)
        return obj
    end

    warn("[Animator6D] Failed to load animation:", id)
    return nil
end
-- ===============================================

-- ========== FIXED KEYFRAME PARSER ==========
local function ConvertToTable(kfs, startTime, endTime)
    if not (kfs and typeof(kfs) == "Instance" and kfs:IsA("KeyframeSequence")) then
        if typeof(kfs) == "Instance" then
            for _, obj in ipairs(kfs:GetDescendants()) do
                if obj:IsA("KeyframeSequence") then
                    kfs = obj
                    break
                end
            end
        end
    end

    assert(kfs and typeof(kfs) == "Instance" and kfs:IsA("KeyframeSequence"), "Expected KeyframeSequence")

    local seq = {}
    local frames = kfs:GetKeyframes()
    
    for _, frame in ipairs(frames) do
        -- Skip frames outside trim range
        if startTime and frame.Time < startTime then
            continue
        end
        if endTime and frame.Time > endTime then
            continue
        end
        
        local entry = { 
            Time = frame.Time,
            OriginalTime = frame.Time,
            Poses = {}  -- CHANGED: Use Poses instead of Data
        }
        
        -- Adjust time if startTime is specified
        if startTime then
            entry.Time = frame.Time - startTime
        end
        
        -- FIXED: Actually get poses from the frame
        for _, pose in ipairs(frame:GetChildren()) do
            if pose:IsA("Pose") and pose.Weight > 0 then
                entry.Poses[pose.Name] = { 
                    CFrame = pose.CFrame,
                    Weight = pose.Weight
                }
            end
        end
        
        -- Also check for AttachmentPose (R15 accessories)
        for _, pose in ipairs(frame:GetChildren()) do
            if pose:IsA("AttachmentPose") and pose.Weight > 0 then
                entry.Poses[pose.Name] = { 
                    CFrame = pose.CFrame,
                    Weight = pose.Weight,
                    IsAttachment = true
                }
            end
        end
        
        table.insert(seq, entry)
    end
    
    -- If trimmed and no frames at time 0, add a dummy frame
    if startTime and startTime > 0 and (#seq == 0 or seq[1].Time > 0) then
        table.insert(seq, 1, { Time = 0, Poses = {}, OriginalTime = startTime })
    end
    
    table.sort(seq, function(a, b) return a.Time < b.Time end)
    return seq, kfs.Loop
end

-- ========== TRIM UTILITY FUNCTIONS ==========
local function CreateTrimmedKeyframeSequence(kfs, startTime, endTime)
    local newKfs = Instance.new("KeyframeSequence")
    newKfs.Name = "Trimmed_" .. kfs.Name
    newKfs.Priority = kfs.Priority
    newKfs.Loop = kfs.Loop
    
    local frames = kfs:GetKeyframes()
    for _, frame in ipairs(frames) do
        if frame.Time >= startTime and frame.Time <= endTime then
            local newFrame = frame:Clone()
            newFrame.Time = frame.Time - startTime
            newFrame.Parent = newKfs
        end
    end
    
    if #newKfs:GetChildren() == 0 then
        local dummyFrame = Instance.new("Keyframe")
        dummyFrame.Time = 0
        dummyFrame.Parent = newKfs
    end
    
    return newKfs
end

local function AnalyzeAnimation(kfs)
    local frames = kfs:GetKeyframes()
    local info = {
        frameCount = #frames,
        totalDuration = frames[#frames] and frames[#frames].Time or 0,
        frames = {}
    }
    
    for i, frame in ipairs(frames) do
        -- FIXED: Count actual poses
        local poseCount = 0
        for _, child in ipairs(frame:GetChildren()) do
            if child:IsA("Pose") or child:IsA("AttachmentPose") then
                poseCount = poseCount + 1
            end
        end
        
        table.insert(info.frames, {
            time = frame.Time,
            poseCount = poseCount,
            hasPoses = poseCount > 0
        })
    end
    
    return info
end

-- ========== MOTOR MAP ==========
local R6JointMap = {
    ["Head"] = "Neck",
    ["Torso"] = "RootJoint",
    ["Right Arm"] = "Right Shoulder",
    ["Left Arm"] = "Left Shoulder",
    ["Right Leg"] = "Right Hip",
    ["Left Leg"] = "Left Hip"
}

local R15JointMap = {
    ["Head"] = "Neck",
    ["UpperTorso"] = "Waist",
    ["LowerTorso"] = "RootJoint",
    ["RightUpperArm"] = "RightShoulder",
    ["RightLowerArm"] = "RightElbow",
    ["RightHand"] = "RightWrist",
    ["LeftUpperArm"] = "LeftShoulder",
    ["LeftLowerArm"] = "LeftElbow",
    ["LeftHand"] = "LeftWrist",
    ["RightUpperLeg"] = "RightHip",
    ["RightLowerLeg"] = "RightKnee",
    ["RightFoot"] = "RightAnkle",
    ["LeftUpperLeg"] = "LeftHip",
    ["LeftLowerLeg"] = "LeftKnee",
    ["LeftFoot"] = "LeftAnkle"
}

local function BuildMotorMap(rig)
    local map, lower, allMotors = {}, {}, {}
    
    for _, m in ipairs(rig:GetDescendants()) do
        if m:IsA("Motor6D") then
            map[m.Name] = m
            lower[string.lower(m.Name)] = m
            table.insert(allMotors, m)
        end
    end
    
    if RIG_TYPE == "R15" then
        for _, accessory in ipairs(rig:GetDescendants()) do
            if accessory:IsA("Accessory") then
                local handle = accessory:FindFirstChild("Handle")
                if handle then
                    for _, attachment in ipairs(handle:GetDescendants()) do
                        if attachment:IsA("Attachment") then
                            map[attachment.Name] = attachment
                            lower[string.lower(attachment.Name)] = attachment
                        end
                    end
                end
            end
        end
    end
    
    return map, lower, allMotors
end

local function FindMotor(poseName, map, lower)
    local jointMap = RIG_TYPE == "R6" and R6JointMap or R15JointMap
    local match = jointMap[poseName] or poseName
    
    local motor = map[match] or lower[string.lower(match)]
    
    if not motor and RIG_TYPE == "R15" then
        local variations = {
            [poseName .. "RigAttachment"] = poseName,
            [poseName .. "Attachment"] = poseName,
            [poseName:gsub(" ", "")] = poseName
        }
        
        for variation in pairs(variations) do
            motor = map[variation] or lower[string.lower(variation)]
            if motor then break end
        end
    end
    
    return motor
end

-- ========== ANIM PLAYER ==========
local AnimPlayer = {}
AnimPlayer.__index = AnimPlayer

function AnimPlayer.new(rig, kfs, startTime, endTime)
    local self = setmetatable({}, AnimPlayer)
    self.rig = rig
    self.seq, self.looped = ConvertToTable(kfs, startTime, endTime)
    self.map, self.lower, self.allMotors = BuildMotorMap(rig)
    self.time, self.playing = 0, false
    self.length = self.seq[#self.seq] and self.seq[#self.seq].Time or 0
    self.speed = 1
    self.savedC0 = {}
    self.savedTransforms = {}
    self.trimStart = startTime or 0
    self.trimEnd = endTime
    
    for _, motor in ipairs(self.allMotors) do
        self.savedC0[motor] = motor.C0
        self.savedTransforms[motor] = motor.Transform
    end
    
    return self
end

function AnimPlayer:Play(speed, loop)
    if self.playing then return end
    self.playing, self.speed = true, speed or 1
    self.looped = (loop == nil) and true or loop

    self.conn = RunService.Heartbeat:Connect(function(dt)
        if not self.playing then return end
        self.time = self.time + (dt * self.speed)

        if self.time > self.length then
            if self.looped then
                self.time = self.time - self.length
            else
                self:Stop(true)
                return
            end
        end

        local prev = self.seq[1]
        for i = 1, #self.seq do
            if self.seq[i].Time <= self.time then
                prev = self.seq[i]
            else
                break
            end
        end

        -- FIXED: Use Poses instead of Data
        for poseName, poseData in pairs(prev.Poses) do
            local motor = FindMotor(poseName, self.map, self.lower)
            if motor and poseData.CFrame then
                pcall(function()
                    if motor:IsA("Motor6D") then
                        motor.C0 = self.savedC0[motor] * poseData.CFrame
                    elseif motor:IsA("Attachment") and RIG_TYPE == "R15" then
                        motor.WorldCFrame = poseData.CFrame
                    end
                end)
            end
        end
    end)
end

function AnimPlayer:Stop(restore)
    self.playing = false
    if self.conn then self.conn:Disconnect() self.conn = nil end
    
    if restore then
        for motor, origC0 in pairs(self.savedC0) do
            pcall(function() 
                if motor:IsA("Motor6D") then
                    motor.C0 = origC0 
                end
            end)
        end
    else
        for motor, origTransform in pairs(self.savedTransforms) do
            pcall(function() 
                if motor:IsA("Motor6D") then
                    motor.Transform = CFrame.new() 
                end
            end)
        end
    end
end

-- ========== DISABLE DEFAULT ANIMS ==========
local function disableDefaultAnimations(char)
    if not hum then return end
    for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
        track:Stop(0)
    end
    local animScript = char:FindFirstChild("Animate")
    if animScript then animScript.Disabled = true end
    local animator = hum:FindFirstChildOfClass("Animator")
    if animator then animator:Destroy() end
end

-- ========== GLOBAL INTERFACE ==========
getgenv().Animator6D = function(idOrInstance, speed, looped, startTime, endTime)
    local kfs
    if typeof(idOrInstance) == "Instance" then
        kfs = idOrInstance:IsA("KeyframeSequence") and idOrInstance or idOrInstance:FindFirstChildOfClass("KeyframeSequence")
    else
        local asset = LoadLocalAsset(idOrInstance)
        if asset then
            kfs = asset:FindFirstChildOfClass("KeyframeSequence") or asset
        end
    end

    if not kfs then
        warn("[Animator6D] Could not load animation:", idOrInstance)
        return
    end

    if startTime or endTime then
        local frames = kfs:GetKeyframes()
        local totalTime = frames[#frames] and frames[#frames].Time or 0
        warn(string.format("[Animator6D] Trimming: %.2fs to %.2fs (total: %.2fs)", 
            startTime or 0, endTime or totalTime, totalTime))
    end

    disableDefaultAnimations(character)

    if getgenv().currentAnimator6D then
        pcall(function()
            getgenv().currentAnimator6D:Stop(true)
        end)
    end

    local anim = AnimPlayer.new(character, kfs, startTime, endTime)
    getgenv().currentAnimator6D = anim
    anim:Play(speed or 1, looped)
    
    return anim
end

-- Trim-specific function
getgenv().Animator6DTrim = function(idOrInstance, startTime, endTime, speed, looped)
    return getgenv().Animator6D(idOrInstance, speed or 1, looped == nil and true or looped, startTime, endTime)
end

-- Fixed AnalyzeAnimation function:
local function AnalyzeAnimation(kfs)
    local frames = kfs:GetKeyframes()
    local info = {
        frameCount = #frames,
        totalDuration = frames[#frames] and frames[#frames].Time or 0,
        frames = {}
    }
    
    for i, frame in ipairs(frames) do
        -- CORRECT WAY: Count actual child poses
        local poseCount = 0
        for _, child in ipairs(frame:GetChildren()) do
            if child:IsA("Pose") or child:IsA("AttachmentPose") then
                poseCount = poseCount + 1
            end
        end
        
        table.insert(info.frames, {
            time = frame.Time,
            poseCount = poseCount,
            hasPoses = poseCount > 0
        })
    end
    
    return info
end

-- Also, in the ConvertToTable function, we need to fix how we check for frames with poses:
local function ConvertToTable(kfs, startTime, endTime)
    if not (kfs and typeof(kfs) == "Instance" and kfs:IsA("KeyframeSequence")) then
        if typeof(kfs) == "Instance" then
            for _, obj in ipairs(kfs:GetDescendants()) do
                if obj:IsA("KeyframeSequence") then
                    kfs = obj
                    break
                end
            end
        end
    end

    assert(kfs and typeof(kfs) == "Instance" and kfs:IsA("KeyframeSequence"), "Expected KeyframeSequence")

    local seq = {}
    local frames = kfs:GetKeyframes()
    
    for _, frame in ipairs(frames) do
        -- Skip frames outside trim range
        if startTime and frame.Time < startTime then
            continue
        end
        if endTime and frame.Time > endTime then
            continue
        end
        
        local entry = { 
            Time = frame.Time,
            OriginalTime = frame.Time,
            Poses = {}
        }
        
        -- Adjust time if startTime is specified
        if startTime then
            entry.Time = frame.Time - startTime
        end
        
        -- CORRECT: Get poses from frame's children
        for _, pose in ipairs(frame:GetChildren()) do
            if pose:IsA("Pose") and pose.Weight > 0 then
                entry.Poses[pose.Name] = { 
                    CFrame = pose.CFrame,
                    Weight = pose.Weight
                }
            end
        end
        
        -- Also check for AttachmentPose
        for _, pose in ipairs(frame:GetChildren()) do
            if pose:IsA("AttachmentPose") and pose.Weight > 0 then
                entry.Poses[pose.Name] = { 
                    CFrame = pose.CFrame,
                    Weight = pose.Weight,
                    IsAttachment = true
                }
            end
        end
        
        table.insert(seq, entry)
    end
    
    -- If trimmed and no frames at time 0, add a dummy frame
    if startTime and startTime > 0 and (#seq == 0 or seq[1].Time > 0) then
        table.insert(seq, 1, { Time = 0, Poses = {}, OriginalTime = startTime })
    end
    
    table.sort(seq, function(a, b) return a.Time < b.Time end)
    return seq, kfs.Loop
end

getgenv().Animator6DStop = function()
    if getgenv().currentAnimator6D then
        pcall(function() getgenv().currentAnimator6D:Stop(true) end)
        getgenv().currentAnimator6D = nil
    end
end

-- ========== CHARACTER REINIT ==========
player.CharacterAdded:Connect(function(newChar)
    character = newChar
    hum = character:WaitForChild("Humanoid")
    RIG_TYPE = GetRigType()
    warn("[Animator6D] Character respawned, rig type:", RIG_TYPE)
end)

-- ========== NOTIFY ==========
warn("[Animator6D Pro V6.1] Loaded with Fixed Pose Handling!")
pcall(function()
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Animator6D Pro V6.1",
        Text = "Fixed Pose Handling + Trimming!",
        Duration = 5
    })
end)

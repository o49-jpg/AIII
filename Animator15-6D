--//====================================================\\--
--||                Animator6D Pro V4 (R6/R15)          ||--
--||  Author: gObl00x + GPT-5                          ||--
--||  Features: universal rig, local cache, safe play   ||--
--||  Custom model support for R15 games               ||--
--\\====================================================//--

if getgenv().Animator6DLoadedPro then return end
getgenv().Animator6DLoadedPro = true

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hum = character:WaitForChild("Humanoid")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- ========== LOCAL CACHE / 403 EVASION ==========
local LocalAssetCache = {}
local fullModel = nil
pcall(function()
	fullModel = game:GetObjects("rbxassetid://107495486817639")[1]
	if fullModel then
		fullModel.Parent = workspace
	end
end)

local function LoadLocalAsset(id)
	id = tostring(id):gsub("^rbxassetid://", "")
	if LocalAssetCache[id] then
		return LocalAssetCache[id]
	end

	local found = fullModel and fullModel:FindFirstChild(id, true)
	if found then
		LocalAssetCache[id] = found
		warn("[Animator6D] âœ… Loaded from local cache:", id)
		return found
	end

	local ok, obj = pcall(function()
		return game:GetObjects("rbxassetid://" .. id)[1]
	end)
	if ok and obj then
		LocalAssetCache[id] = obj
		warn("[Animator6D] âœ… Loaded via GetObjectsðŸ‘ðŸ‘:", id)
		return obj
	end

	warn("[Animator6D] ts is bad, failed to load animation:", id)
	return nil
end
-- ===============================================

-- ========== RIG DETECTION ==========
local function IsR15(character)
	return hum.RigType == Enum.HumanoidRigType.R15
end

local function GetRigType()
	return IsR15(character) and "R15" or "R6"
end

-- ========== IMPROVED MOTOR MAPPINGS ==========
local R6Map = {
	["Head"] = "Neck",
	["Torso"] = "RootJoint",
	["Right Arm"] = "Right Shoulder",
	["Left Arm"] = "Left Shoulder",
	["Right Leg"] = "Right Hip",
	["Left Leg"] = "Left Hip"
}

-- Enhanced R15 mapping with common custom model variations
local R15Map = {
	-- Standard R15 parts
	["Head"] = "Neck",
	["UpperTorso"] = "Waist",
	["LeftUpperArm"] = "LeftShoulder",
	["RightUpperArm"] = "RightShoulder",
	["LowerTorso"] = "Root",
	["LeftUpperLeg"] = "LeftHip",
	["RightUpperLeg"] = "RightHip",
	
	-- Additional R15 joints
	["LeftLowerArm"] = "LeftElbow",
	["RightLowerArm"] = "RightElbow",
	["LeftLowerLeg"] = "LeftKnee",
	["RightLowerLeg"] = "RightKnee",
	["LeftFoot"] = "LeftAnkle",
	["RightFoot"] = "RightAnkle",
	
	-- Common custom model variations
	["UpperTorsoHatch"] = "Waist",
	["LowerTorsoHatch"] = "Root",
	["Pelvis"] = "Root",
	["Hips"] = "Root",
	["Spine"] = "Waist",
	["Spine1"] = "Waist",
	["Spine2"] = "Waist",
	["Chest"] = "Waist",
	
	-- Shoulder/arm variations
	["LeftArm"] = "LeftShoulder",
	["RightArm"] = "RightShoulder",
	["LeftShoulderGroup"] = "LeftShoulder",
	["RightShoulderGroup"] = "RightShoulder",
	["LeftUpperArmGroup"] = "LeftShoulder",
	["RightUpperArmGroup"] = "RightShoulder",
	
	-- Hand variations
	["LeftHand"] = "LeftWrist",
	["RightHand"] = "RightWrist",
	
	-- Custom Freddy joints based on your structure
	["UpperHalf"] = "Waist",
	["Bowtie"] = "Waist",
	["LeftShoulderPad"] = "LeftShoulder",
	["RightShoulderPad"] = "RightShoulder",
	["Neck"] = "Neck",
	["UpperTorsoHatch"] = "Waist",
	["LowerTorsoHatch"] = "Root",
	["RightElbowGroup"] = "RightElbow",
	["LeftElbowGroup"] = "LeftElbow"
}

-- Fallback mappings for different naming conventions
local R15MapAlt = {
	["Torso"] = "Waist",
	["Left Arm"] = "LeftShoulder",
	["Right Arm"] = "RightShoulder",
	["Left Leg"] = "LeftHip",
	["Right Leg"] = "RightHip",
	["HumanoidRootPart"] = "Root"
}

-- ========== MINIMAL R15 CORRECTION ==========
local R15_Root_Correction = CFrame.Angles(0, math.rad(180), 0)

-- ========== KEYFRAME PARSER ==========
local function ConvertToTable(kfs)
	if not (kfs and typeof(kfs) == "Instance" and kfs:IsA("KeyframeSequence")) then
		if typeof(kfs) == "Instance" then
			for _, obj in ipairs(kfs:GetDescendants()) do
				if obj:IsA("KeyframeSequence") then
					kfs = obj
					break
				end
			end
		end
	end

	assert(kfs and typeof(kfs) == "Instance" and kfs:IsA("KeyframeSequence"), "Expected KeyframeSequence")

	local seq = {}
	for _, frame in ipairs(kfs:GetKeyframes()) do
		local entry = { Time = frame.Time, Data = {} }
		for _, pose in ipairs(frame:GetDescendants()) do
			if pose:IsA("Pose") and pose.Weight > 0 then
				-- Check if this is a root pose
				local isRootPose = pose.Name == "HumanoidRootPart" or pose.Name == "Torso" or pose.Name == "LowerTorso" or 
								  pose.Name == "UpperTorso" or pose.Name == "Pelvis" or pose.Name == "Hips"
				entry.Data[pose.Name] = { 
					CFrame = pose.CFrame,
					IsRoot = isRootPose
				}
			end
		end
		table.insert(seq, entry)
	end
	table.sort(seq, function(a, b) return a.Time < b.Time end)
	return seq, kfs.Loop
end

-- ========== IMPROVED MOTOR MAP FOR CUSTOM MODELS ==========
local function BuildMotorMap(rig)
	local map = {}
	local lower = {}
	local partToMotor = {}  -- Map part names to their motors
	local motorParts = {}   -- Map motor names to their attached parts
	
	-- First pass: collect all Motor6Ds
	for _, m in ipairs(rig:GetDescendants()) do
		if m:IsA("Motor6D") then
			local motorName = m.Name
			map[motorName] = m
			lower[string.lower(motorName)] = m
			
			-- Map the part that this motor moves
			if m.Part1 then
				local partName = m.Part1.Name
				partToMotor[partName] = m
				motorParts[motorName] = partName
				
				-- Also add part name as direct mapping
				if not map[partName] then
					map[partName] = m
				end
				
				-- Add common variations
				local lowerPartName = string.lower(partName)
				if string.find(lowerPartName, "upperarm") then
					if string.find(lowerPartName, "left") then
						map["LeftUpperArm"] = m
					elseif string.find(lowerPartName, "right") then
						map["RightUpperArm"] = m
					end
				elseif string.find(lowerPartName, "lowerarm") then
					if string.find(lowerPartName, "left") then
						map["LeftLowerArm"] = m
					elseif string.find(lowerPartName, "right") then
						map["RightLowerArm"] = m
					end
				elseif string.find(lowerPartName, "uppertorso") then
					map["UpperTorso"] = m
				elseif string.find(lowerPartName, "lowertorso") then
					map["LowerTorso"] = m
				elseif string.find(lowerPartName, "head") then
					map["Head"] = m
				elseif string.find(lowerPartName, "neck") then
					map["Neck"] = m
				elseif string.find(lowerPartName, "root") or string.find(lowerPartName, "pelvis") then
					map["Root"] = m
				end
			end
		end
	end
	
	-- Second pass: handle nested Motor6Ds in custom models
	for _, m in ipairs(rig:GetDescendants()) do
		if m:IsA("Motor6D") then
			-- Check parent hierarchy for custom models
			local current = m.Parent
			while current and current ~= rig do
				if current:IsA("BasePart") then
					local partName = current.Name
					-- Add parent part name mapping
					if not map[partName] then
						map[partName] = m
					end
				end
				current = current.Parent
			end
		end
	end
	
	-- Try to find root motor if not already found
	if not map["Root"] and not map["RootJoint"] then
		for motorName, motor in pairs(map) do
			local lowerName = string.lower(motorName)
			if string.find(lowerName, "root") or string.find(lowerName, "pelvis") or 
			   string.find(lowerName, "hips") then
				map["Root"] = motor
				map["RootJoint"] = motor
				break
			end
		end
	end
	
	-- Try to find waist motor if not already found
	if not map["Waist"] then
		for motorName, motor in pairs(map) do
			local lowerName = string.lower(motorName)
			if string.find(lowerName, "waist") or string.find(lowerName, "spine") or 
			   string.find(lowerName, "chest") or string.find(lowerName, "uppertorso") then
				map["Waist"] = motor
				break
			end
		end
	end
	
	return map, lower, partToMotor, motorParts
end

local function FindMotor(poseName, map, lower, isR15)
	-- First try direct mapping
	if map[poseName] then
		return map[poseName]
	end
	
	-- Try R15 mapping
	if isR15 then
		local r15Match = R15Map[poseName] or R15MapAlt[poseName]
		if r15Match then
			return map[r15Match] or lower[string.lower(r15Match)]
		end
	end
	
	-- Try case-insensitive search
	local lowerPoseName = string.lower(poseName)
	for key, motor in pairs(map) do
		local lowerKey = string.lower(key)
		if string.find(lowerKey, lowerPoseName) or string.find(lowerPoseName, lowerKey) then
			return motor
		end
	end
	
	-- Try partial matching for custom models
	for key, motor in pairs(map) do
		local lowerKey = string.lower(key)
		-- Check for common substrings
		local patterns = {
			"arm", "leg", "torso", "head", "neck", "shoulder", "hip", "knee", "elbow", "ankle", "wrist"
		}
		
		for _, pattern in ipairs(patterns) do
			if string.find(lowerPoseName, pattern) and string.find(lowerKey, pattern) then
				-- Additional check for left/right alignment
				local hasLeft = string.find(lowerPoseName, "left") and string.find(lowerKey, "left")
				local hasRight = string.find(lowerPoseName, "right") and string.find(lowerKey, "right")
				local hasNeither = not string.find(lowerPoseName, "left") and not string.find(lowerPoseName, "right") and
								  not string.find(lowerKey, "left") and not string.find(lowerKey, "right")
				
				if hasLeft or hasRight or hasNeither then
					return motor
				end
			end
		end
	end
	
	-- R6 mapping (fallback)
	local match = R6Map[poseName] or poseName
	return map[match] or lower[string.lower(match)]
end

-- ========== MINIMAL R15 CORRECTION ==========
local function ApplyR15Correction(motor, origC0, dataCFrame, poseName, isR15)
	if not isR15 then
		return origC0 * dataCFrame
	end
	
	-- Only apply correction to root/waist joints for forward direction
	local motorName = motor.Name
	if motorName == "Root" or motorName == "RootJoint" or motorName == "Waist" or 
	   string.find(string.lower(motorName), "root") or string.find(string.lower(motorName), "waist") then
		-- Check if this is a root pose
		if poseName == "HumanoidRootPart" or poseName == "Torso" or poseName == "LowerTorso" or 
		   poseName == "UpperTorso" or poseName == "Pelvis" or poseName == "Hips" then
			-- Apply minimal correction only to fix forward direction
			return origC0 * R15_Root_Correction * dataCFrame
		end
	end
	
	-- For all other joints, apply animation directly (no correction)
	return origC0 * dataCFrame
end

local function FixR15RootMovement(rootCFrame)
	-- Only apply 180-degree Y rotation to fix forward direction
	return CFrame.new(rootCFrame.Position) * R15_Root_Correction * rootCFrame.Rotation
end

-- ========== ANIM PLAYER ==========
local AnimPlayer = {}
AnimPlayer.__index = AnimPlayer

function AnimPlayer.new(rig, kfs)
	local self = setmetatable({}, AnimPlayer)
	self.rig = rig
	self.seq, self.looped = ConvertToTable(kfs)
	self.map, self.lower, self.partToMotor, self.motorParts = BuildMotorMap(rig)
	self.time, self.playing = 0, false
	self.length = self.seq[#self.seq].Time
	self.speed = 1
	self.isR15 = IsR15(rig)
	self.savedC0 = {}
	
	-- Debug: Show found motors
	warn("[Animator6D] Found motors:")
	for name, motor in pairs(self.map) do
		if motor:IsA("Motor6D") then
			local partName = motor.Part1 and motor.Part1.Name or "None"
			warn("  - " .. name .. " -> " .. motor.Name .. " (Part: " .. partName .. ")")
		end
	end
	
	-- Find root motor
	self.rootMotor = self.map["Root"] or self.map["RootJoint"] or self.map["Pelvis"] or self.map["Hips"]
	
	-- Save original C0 values
	for _, m in pairs(self.map) do
		if m:IsA("Motor6D") then
			self.savedC0[m] = m.C0
		end
	end
	
	-- Handle R15 specific setup
	if self.isR15 then
		warn("[Animator6D] Detected R15 character - using custom model support")
	end
	
	-- Store original root part state
	if humanoidRootPart then
		self.originalRootCFrame = humanoidRootPart.CFrame
	end
	
	return self
end

function AnimPlayer:Play(speed, loop)
	if self.playing then return end
	self.playing, self.speed = true, speed or 1
	self.looped = (loop == nil) and true or loop
	
	-- Store start time for root movement
	self.startTime = tick()
	self.lastFrameTime = tick()
	
	-- Track previous root CFrame for delta calculation
	self.prevRootCFrame = nil
	self.accumulatedRootDelta = CFrame.new()

	self.conn = RunService.Heartbeat:Connect(function(dt)
		if not self.playing then return end
		
		local currentTime = tick()
		local frameDelta = currentTime - self.lastFrameTime
		self.lastFrameTime = currentTime
		
		self.time += dt * self.speed

		if self.time > self.length then
			if self.looped then
				self.time -= self.length
				-- Reset root delta on loop
				self.accumulatedRootDelta = CFrame.new()
			else
				self:Stop(true)
				return
			end
		end

		local prev = self.seq[1]
		for i = 1, #self.seq do
			if self.seq[i].Time <= self.time then
				prev = self.seq[i]
			else
				break
			end
		end

		-- Track if we have root movement this frame
		local hasRootMovement = false
		local rootCFrame = nil
		local rootPoseName = nil
		
		for joint, data in pairs(prev.Data) do
			local motor = FindMotor(joint, self.map, self.lower, self.isR15)
			if motor then
				pcall(function()
					if data.IsRoot then
						-- This is a root movement pose
						hasRootMovement = true
						rootCFrame = data.CFrame
						rootPoseName = joint
						
						-- Apply to root motor if it exists
						if self.rootMotor then
							self.rootMotor.C0 = ApplyR15Correction(self.rootMotor, self.savedC0[self.rootMotor], data.CFrame, joint, self.isR15)
						end
					else
						-- Regular pose - apply animation directly
						motor.C0 = ApplyR15Correction(motor, self.savedC0[motor], data.CFrame, joint, self.isR15)
					end
				end)
			else
				-- Try alternative search for custom model parts
				local lowerJoint = string.lower(joint)
				for motorName, motor in pairs(self.map) do
					local lowerMotorName = string.lower(motorName)
					if string.find(lowerMotorName, lowerJoint) or string.find(lowerJoint, lowerMotorName) then
						pcall(function()
							motor.C0 = ApplyR15Correction(motor, self.savedC0[motor], data.CFrame, joint, self.isR15)
						end)
						break
					end
				end
			end
		end
		
		-- Apply root movement if present (simplified for custom models)
		if hasRootMovement and rootCFrame and humanoidRootPart then
			if self.prevRootCFrame then
				local delta = self.prevRootCFrame:Inverse() * rootCFrame
				self.accumulatedRootDelta = self.accumulatedRootDelta * delta
				
				-- Apply movement to character (only horizontal)
				local targetPosition = (self.originalRootCFrame * self.accumulatedRootDelta).Position
				local horizontalTarget = Vector3.new(targetPosition.X, humanoidRootPart.Position.Y, targetPosition.Z)
				
				if (horizontalTarget - humanoidRootPart.Position).Magnitude > 0.1 then
					local direction = (horizontalTarget - humanoidRootPart.Position).Unit
					local distance = (horizontalTarget - humanoidRootPart.Position).Magnitude
					local speed = math.min(distance / frameDelta, 30)
					
					humanoidRootPart.Velocity = direction * speed
					hum:Move(direction * speed)
				end
			end
			self.prevRootCFrame = rootCFrame
		end
	end)
end

function AnimPlayer:Stop(restore)
	self.playing = false
	
	if self.conn then 
		self.conn:Disconnect() 
		self.conn = nil 
	end
	
	-- Reset root part velocity
	if humanoidRootPart then
		humanoidRootPart.Velocity = Vector3.new()
	end
	
	if restore then
		-- Restore motor positions
		for motor, origC0 in pairs(self.savedC0) do
			pcall(function() 
				motor.C0 = origC0 
			end)
		end
	else
		-- Reset motor transforms
		for _, m in pairs(self.map) do
			if m:IsA("Motor6D") then
				pcall(function() 
					m.Transform = CFrame.new() 
				end)
			end
		end
	end
	
	-- Reset accumulated root delta
	self.accumulatedRootDelta = CFrame.new()
	self.prevRootCFrame = nil
end

-- ========== DISABLE DEFAULT ANIMS ==========
local function disableDefaultAnimations(char)
	if not hum then return end
	for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
		track:Stop(0)
	end
	local animScript = char:FindFirstChild("Animate")
	if animScript then animScript.Disabled = true end
	local animator = hum:FindFirstChildOfClass("Animator")
	if animator then animator:Destroy() end
end

-- ========== CUSTOM MODEL SUPPORT ==========
getgenv().Animator6DUseCustomModel = function(model)
	if not model or not model:IsA("Model") then
		warn("[Animator6D] Invalid model provided")
		return
	end
	
	-- Set the custom model as the character to animate
	character = model
	hum = model:FindFirstChildOfClass("Humanoid") or model:WaitForChild("Humanoid")
	humanoidRootPart = model:FindFirstChild("HumanoidRootPart") or model.PrimaryPart
	
	warn("[Animator6D] Using custom model:", model.Name)
end

-- ========== GLOBAL INTERFACE ==========
getgenv().Animator6D = function(idOrInstance, speed, looped)
	local kfs
	if typeof(idOrInstance) == "Instance" then
		kfs = idOrInstance:IsA("KeyframeSequence") and idOrInstance or idOrInstance:FindFirstChildOfClass("KeyframeSequence")
	else
		local asset = LoadLocalAsset(idOrInstance)
		if asset then
			kfs = asset:FindFirstChildOfClass("KeyframeSequence") or asset
		end
	end

	if not kfs then
		warn("[Animator6D] yo sorry could not load animation:", idOrInstance)
		return
	end

	disableDefaultAnimations(character)

	if getgenv().currentAnimator6D then
		pcall(function()
			getgenv().currentAnimator6D:Stop(true)
		end)
	end

	local anim = AnimPlayer.new(character, kfs)
	getgenv().currentAnimator6D = anim
	anim.animId = typeof(idOrInstance) == "number" and idOrInstance or nil
	anim.speed = speed or 1
	anim.looped = looped
	anim:Play(speed or 1, looped)
	
	warn("[Animator6D] Playing animation on", GetRigType(), "character:", character.Name)
end

getgenv().Animator6DStop = function()
	if getgenv().currentAnimator6D then
		pcall(function() getgenv().currentAnimator6D:Stop(true) end)
		getgenv().currentAnimator6D = nil
	end
end

-- ========== NOTIFY ==========
warn("[Animator6D Pro V4] ya.. Allah hotbar")
warn("[Animator6D Pro V4] Now with custom R15 model support!")
pcall(function()
	game:GetService("StarterGui"):SetCore("SendNotification", {
		Title = "Animator6D Pro V4",
		Text = "Loaded with custom R15 model support!",
		Duration = 5
	})
end)

--
--[[
(pls, If ur down here, read these instructions)

FOR CUSTOM MODELS (like your Glamrock Freddy):
1. First, set your custom model:
   getgenv().Animator6DUseCustomModel(workspace.O49_R.GlamrockFreddy)
   
2. Then play animations:
   getgenv().Animator6D(1234567890, 1, true)

OR for standard player character:
getgenv().Animator6D(1234567890, 1, true) -- idOrInstance, Speed, Looped? --

If u will be using an instance and not an ID, then:
local animInstance = game:GetObjects("rbxassetid://ID")[1]..Here the KeyframeSequence Path -- replace ID with the ID --
getgenv().Animator6D(animInstance, 1, true) -- or false if u want the anim to have a loop

If u want to stop the anim outside ts loadstring, then:
getgenv().Animator6DStop()
--]]

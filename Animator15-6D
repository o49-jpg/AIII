--//====================================================\\--
--||               Animator6D Pro V5 (Ultimate)        ||--
--||  Author: gObl00x + GPT-5                         ||--
--||  Features: universal rig, local cache, safe play  ||--
--||  Auto-detects ANY model, R6/R15, custom models   ||--
--\\====================================================//--

if getgenv().Animator6DLoadedPro then return end
getgenv().Animator6DLoadedPro = true

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer

-- ========== AUTO MODEL DETECTION SYSTEM ==========
local function FindAvailableModel()
    local foundModels = {}
    
    -- 1. First priority: Player's character
    local char = player.Character
    if char then
        -- Check if character has Motor6Ds (custom model)
        local hasMotor6D = false
        for _, obj in ipairs(char:GetDescendants()) do
            if obj:IsA("Motor6D") then
                hasMotor6D = true
                break
            end
        end
        
        if hasMotor6D then
            table.insert(foundModels, {model = char, priority = 1, name = "Player Custom Model"})
        else
            -- Standard R6/R15 character
            table.insert(foundModels, {model = char, priority = 2, name = "Player Character"})
        end
    end
    
    -- 2. Second priority: Models in O49_R folder
    local o49Folder = workspace:FindFirstChild("O49_R")
    if o49Folder then
        for _, model in ipairs(o49Folder:GetChildren()) do
            if model:IsA("Model") then
                local hasMotor6D = false
                for _, obj in ipairs(model:GetDescendants()) do
                    if obj:IsA("Motor6D") then
                        hasMotor6D = true
                        break
                    end
                end
                
                if hasMotor6D then
                    table.insert(foundModels, {model = model, priority = 3, name = "O49_R Model: " .. model.Name})
                end
            end
        end
    end
    
    -- 3. Third priority: Any model in workspace with Motor6Ds
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model ~= char then
            local hasMotor6D = false
            local motorCount = 0
            for _, obj in ipairs(model:GetDescendants()) do
                if obj:IsA("Motor6D") then
                    hasMotor6D = true
                    motorCount = motorCount + 1
                end
            end
            
            if hasMotor6D and motorCount >= 3 then -- Require at least 3 motors to be a valid rig
                table.insert(foundModels, {model = model, priority = 4, name = "Workspace Model: " .. model.Name})
            end
        end
    end
    
    -- Sort by priority (lower number = higher priority)
    table.sort(foundModels, function(a, b) return a.priority < b.priority end)
    
    if #foundModels > 0 then
        return foundModels[1].model, foundModels[1].name
    end
    
    return nil, "No models found"
end

-- Initialize character
local character, hum, humanoidRootPart
local currentModelType = ""

local function UpdateCharacter()
    local model, modelInfo = FindAvailableModel()
    
    if model then
        character = model
        hum = character:FindFirstChildOfClass("Humanoid")
        humanoidRootPart = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
        currentModelType = modelInfo
        
        warn("[Animator6D] Using:", modelInfo)
        warn("[Animator6D] Model name:", character.Name)
        
        if hum then
            warn("[Animator6D] Rig type:", hum.RigType == Enum.HumanoidRigType.R15 and "R15" or "R6")
        else
            warn("[Animator6D] No Humanoid found (custom rig)")
        end
    else
        -- Fallback: wait for player character
        character = player.Character or player.CharacterAdded:Wait()
        hum = character:WaitForChild("Humanoid")
        humanoidRootPart = character:WaitForChild("HumanoidRootPart")
        currentModelType = "Player Character (Fallback)"
        warn("[Animator6D] Using fallback player character")
    end
end

-- Initial character setup
UpdateCharacter()

-- ========== LOCAL CACHE / 403 EVASION ==========
local LocalAssetCache = {}
local fullModel = nil
pcall(function()
    fullModel = game:GetObjects("rbxassetid://107495486817639")[1]
    if fullModel then
        fullModel.Parent = workspace
    end
end)

local function LoadLocalAsset(id)
    id = tostring(id):gsub("^rbxassetid://", "")
    if LocalAssetCache[id] then
        return LocalAssetCache[id]
    end

    local found = fullModel and fullModel:FindFirstChild(id, true)
    if found then
        LocalAssetCache[id] = found
        warn("[Animator6D] âœ… Loaded from local cache:", id)
        return found
    end

    local ok, obj = pcall(function()
        return game:GetObjects("rbxassetid://" .. id)[1]
    end)
    if ok and obj then
        LocalAssetCache[id] = obj
        warn("[Animator6D] âœ… Loaded via GetObjectsðŸ‘ðŸ‘:", id)
        return obj
    end

    warn("[Animator6D] Failed to load animation:", id)
    return nil
end

-- ========== RIG DETECTION ==========
local function IsR15(model)
    if not model then return false end
    local modelHum = model:FindFirstChildOfClass("Humanoid")
    if modelHum then
        return modelHum.RigType == Enum.HumanoidRigType.R15
    end
    
    -- Heuristic detection for custom models
    local hasUpperTorso = model:FindFirstChild("UpperTorso") or model:FindFirstChild("UpperTorso", true)
    local hasLowerTorso = model:FindFirstChild("LowerTorso") or model:FindFirstChild("LowerTorso", true)
    local hasR6Torso = model:FindFirstChild("Torso")
    
    if hasUpperTorso and hasLowerTorso then
        return true -- Likely R15 or custom R15-based
    elseif hasR6Torso then
        return false -- Likely R6
    end
    
    -- Default to R15 for custom models with unknown structure
    return true
end

-- ========== UNIVERSAL MOTOR MAPPINGS ==========
local R6Map = {
    ["Head"] = "Neck",
    ["Torso"] = "RootJoint",
    ["Right Arm"] = "Right Shoulder",
    ["Left Arm"] = "Left Shoulder",
    ["Right Leg"] = "Right Hip",
    ["Left Leg"] = "Left Hip"
}

local R15Map = {
    -- Standard R15 joints
    ["Head"] = "Neck",
    ["UpperTorso"] = "Waist",
    ["LeftUpperArm"] = "LeftShoulder",
    ["RightUpperArm"] = "RightShoulder",
    ["LowerTorso"] = "Root",
    ["LeftUpperLeg"] = "LeftHip",
    ["RightUpperLeg"] = "RightHip",
    
    -- Additional joints
    ["LeftLowerArm"] = "LeftElbow",
    ["RightLowerArm"] = "RightElbow",
    ["LeftLowerLeg"] = "LeftKnee",
    ["RightLowerLeg"] = "RightKnee",
    ["LeftFoot"] = "LeftAnkle",
    ["RightFoot"] = "RightAnkle",
    
    -- Common variations
    ["Torso"] = "Waist",
    ["Left Arm"] = "LeftShoulder",
    ["Right Arm"] = "RightShoulder",
    ["Left Leg"] = "LeftHip",
    ["Right Leg"] = "RightHip",
    ["HumanoidRootPart"] = "Root",
    
    -- Custom model support
    ["Pelvis"] = "Root",
    ["Hips"] = "Root",
    ["Spine"] = "Waist",
    ["Spine1"] = "Waist",
    ["Spine2"] = "Waist",
    ["Chest"] = "Waist",
    ["UpperChest"] = "Waist",
    
    -- Your Glamrock Freddy joints
    ["UpperHalf"] = "Waist",
    ["Bowtie"] = "Waist",
    ["LeftShoulderPad"] = "LeftShoulder",
    ["RightShoulderPad"] = "RightShoulder",
    ["Neck"] = "Neck",
    ["UpperTorsoHatch"] = "Waist",
    ["LowerTorsoHatch"] = "Root",
    ["RightElbowGroup"] = "RightElbow",
    ["LeftElbowGroup"] = "LeftElbow",
    ["RightShoulderGroup"] = "RightShoulder",
    ["LeftShoulderGroup"] = "LeftShoulder"
}

-- ========== MINIMAL R15 ROTATION CORRECTION ==========
local R15_Root_Correction = CFrame.Angles(0, math.rad(180), 0)

-- ========== KEYFRAME PARSER WITH ROOT MOVEMENT DETECTION ==========
local function ConvertToTable(kfs)
    if not (kfs and typeof(kfs) == "Instance" and kfs:IsA("KeyframeSequence")) then
        if typeof(kfs) == "Instance" then
            for _, obj in ipairs(kfs:GetDescendants()) do
                if obj:IsA("KeyframeSequence") then
                    kfs = obj
                    break
                end
            end
        end
    end

    assert(kfs and typeof(kfs) == "Instance" and kfs:IsA("KeyframeSequence"), "Expected KeyframeSequence")

    local seq = {}
    for _, frame in ipairs(kfs:GetKeyframes()) do
        local entry = { Time = frame.Time, Data = {} }
        for _, pose in ipairs(frame:GetDescendants()) do
            if pose:IsA("Pose") and pose.Weight > 0 then
                -- Enhanced root detection
                local isRootPose = pose.Name == "HumanoidRootPart" or 
                                   pose.Name == "Torso" or 
                                   pose.Name == "LowerTorso" or 
                                   pose.Name == "UpperTorso" or
                                   pose.Name == "Pelvis" or
                                   pose.Name == "Hips"
                entry.Data[pose.Name] = { 
                    CFrame = pose.CFrame,
                    IsRoot = isRootPose
                }
            end
        end
        table.insert(seq, entry)
    end
    table.sort(seq, function(a, b) return a.Time < b.Time end)
    return seq, kfs.Loop
end

-- ========== ADVANCED MOTOR DETECTION FOR CUSTOM MODELS ==========
local function BuildMotorMap(rig)
    local map = {}
    local lower = {}
    local partToMotor = {}
    local motorToPart = {}
    
    -- First pass: collect all Motor6Ds
    for _, m in ipairs(rig:GetDescendants()) do
        if m:IsA("Motor6D") then
            local motorName = m.Name
            map[motorName] = m
            lower[string.lower(motorName)] = m
            
            -- Map part that this motor controls
            if m.Part1 then
                local partName = m.Part1.Name
                partToMotor[partName] = m
                motorToPart[m] = partName
                
                -- Add part name as alias
                if not map[partName] then
                    map[partName] = m
                end
                
                -- Add common variations
                local lowerPartName = string.lower(partName)
                if string.find(lowerPartName, "upperarm") then
                    if string.find(lowerPartName, "left") then
                        map["LeftUpperArm"] = m
                    elseif string.find(lowerPartName, "right") then
                        map["RightUpperArm"] = m
                    end
                elseif string.find(lowerPartName, "lowerarm") then
                    if string.find(lowerPartName, "left") then
                        map["LeftLowerArm"] = m
                    elseif string.find(lowerPartName, "right") then
                        map["RightLowerArm"] = m
                    end
                elseif string.find(lowerPartName, "uppertorso") then
                    map["UpperTorso"] = m
                elseif string.find(lowerPartName, "lowertorso") then
                    map["LowerTorso"] = m
                elseif string.find(lowerPartName, "head") then
                    map["Head"] = m
                elseif string.find(lowerPartName, "neck") then
                    map["Neck"] = m
                elseif string.find(lowerPartName, "root") or string.find(lowerPartName, "pelvis") then
                    map["Root"] = m
                    map["RootJoint"] = m
                elseif string.find(lowerPartName, "waist") or string.find(lowerPartName, "spine") then
                    map["Waist"] = m
                end
            end
        end
    end
    
    -- Second pass: auto-detect key joints
    local keyJoints = {"Root", "Waist", "Neck", "LeftShoulder", "RightShoulder", "LeftHip", "RightHip"}
    
    for _, jointName in ipairs(keyJoints) do
        if not map[jointName] then
            local lowerJoint = string.lower(jointName)
            for motorName, motor in pairs(map) do
                local lowerMotor = string.lower(motorName)
                if string.find(lowerMotor, lowerJoint) then
                    map[jointName] = motor
                    break
                end
            end
        end
    end
    
    -- Third pass: check parent hierarchy for custom models
    for _, m in ipairs(rig:GetDescendants()) do
        if m:IsA("Motor6D") then
            local current = m.Parent
            while current and current ~= rig do
                if current:IsA("BasePart") then
                    local partName = current.Name
                    if not map[partName] then
                        map[partName] = m
                    end
                end
                current = current.Parent
            end
        end
    end
    
    return map, lower, partToMotor, motorToPart
end

-- ========== INTELLIGENT MOTOR FINDING ==========
local function FindMotor(poseName, map, lower, isR15)
    -- Direct lookup
    if map[poseName] then
        return map[poseName]
    end
    
    -- Case-insensitive direct match
    local lowerPoseName = string.lower(poseName)
    for key, motor in pairs(map) do
        if string.lower(key) == lowerPoseName then
            return motor
        end
    end
    
    -- Rig-specific mapping
    if isR15 then
        local r15Match = R15Map[poseName]
        if r15Match and map[r15Match] then
            return map[r15Match]
        end
    else
        local r6Match = R6Map[poseName]
        if r6Match and map[r6Match] then
            return map[r6Match]
        end
    end
    
    -- Smart partial matching
    local candidates = {}
    
    for key, motor in pairs(map) do
        local lowerKey = string.lower(key)
        
        -- Check for exact substring match
        if string.find(lowerKey, lowerPoseName) or string.find(lowerPoseName, lowerKey) then
            -- Score the match
            local score = 0
            
            -- Exact word match gets highest score
            if lowerKey == lowerPoseName then
                score = score + 100
            end
            
            -- Common joint keywords
            local keywords = {"arm", "leg", "torso", "head", "neck", "shoulder", "hip", "elbow", "knee", "ankle", "wrist", "foot", "hand"}
            for _, keyword in ipairs(keywords) do
                if string.find(lowerPoseName, keyword) and string.find(lowerKey, keyword) then
                    score = score + 10
                end
            end
            
            -- Side matching (left/right)
            local poseHasLeft = string.find(lowerPoseName, "left")
            local poseHasRight = string.find(lowerPoseName, "right")
            local keyHasLeft = string.find(lowerKey, "left")
            local keyHasRight = string.find(lowerKey, "right")
            
            if (poseHasLeft and keyHasLeft) or (poseHasRight and keyHasRight) then
                score = score + 20
            elseif (not poseHasLeft and not poseHasRight) and (not keyHasLeft and not keyHasRight) then
                score = score + 5
            end
            
            table.insert(candidates, {motor = motor, score = score})
        end
    end
    
    -- Return best candidate
    if #candidates > 0 then
        table.sort(candidates, function(a, b) return a.score > b.score end)
        return candidates[1].motor
    end
    
    warn("[Animator6D] Could not find motor for pose:", poseName)
    return nil
end

-- ========== MINIMAL R15 CORRECTION (FIXES FORWARD DIRECTION ONLY) ==========
local function ApplyR15Correction(motor, origC0, dataCFrame, poseName, isR15)
    if not isR15 then
        return origC0 * dataCFrame
    end
    
    -- Only apply correction to root joints for forward direction fix
    local motorName = motor.Name
    local lowerName = string.lower(motorName)
    
    -- Check if this motor controls root/waist
    local isRootJoint = string.find(lowerName, "root") or 
                       string.find(lowerName, "waist") or 
                       string.find(lowerName, "pelvis") or
                       string.find(lowerName, "hips")
    
    if isRootJoint then
        -- Check if this is a root pose
        local isRootPose = poseName == "HumanoidRootPart" or 
                          poseName == "Torso" or 
                          poseName == "LowerTorso" or 
                          poseName == "UpperTorso" or
                          poseName == "Pelvis" or
                          poseName == "Hips"
        
        if isRootPose then
            return origC0 * R15_Root_Correction * dataCFrame
        end
    end
    
    -- For arms, head, legs - apply directly without correction
    return origC0 * dataCFrame
end

-- ========== ROOT MOVEMENT CONTROLLER ==========
local RootMovement = {}
RootMovement.__index = RootMovement

function RootMovement.new(rootPart, isR15)
    local self = setmetatable({}, RootMovement)
    self.rootPart = rootPart
    self.isR15 = isR15
    self.originalCFrame = rootPart.CFrame
    self.accumulatedDelta = CFrame.new()
    self.prevRootCFrame = nil
    return self
end

function RootMovement:ApplyMovement(rootCFrame, deltaTime)
    if not self.rootPart then return end
    
    if self.isR15 then
        -- Apply R15 forward correction
        rootCFrame = CFrame.new(rootCFrame.Position) * R15_Root_Correction * rootCFrame.Rotation
    end
    
    if self.prevRootCFrame then
        local delta = self.prevRootCFrame:Inverse() * rootCFrame
        self.accumulatedDelta = self.accumulatedDelta * delta
        
        -- Calculate target position
        local targetPosition = (self.originalCFrame * self.accumulatedDelta).Position
        
        -- Apply movement (horizontal only)
        local currentPos = self.rootPart.Position
        local horizontalTarget = Vector3.new(targetPosition.X, currentPos.Y, targetPosition.Z)
        local moveDir = (horizontalTarget - currentPos)
        
        if moveDir.Magnitude > 0.1 then
            local speed = math.min(moveDir.Magnitude / deltaTime, 30)
            local velocity = moveDir.Unit * speed
            
            -- Apply velocity
            self.rootPart.Velocity = Vector3.new(velocity.X, self.rootPart.Velocity.Y, velocity.Z)
            
            -- Apply rotation
            local currentCF = self.rootPart.CFrame
            local targetCF = CFrame.new(currentPos) * rootCFrame.Rotation
            self.rootPart.CFrame = currentCF:Lerp(targetCF, 0.1)
        end
    end
    
    self.prevRootCFrame = rootCFrame
end

function RootMovement:Reset()
    self.accumulatedDelta = CFrame.new()
    self.prevRootCFrame = nil
    if self.rootPart then
        self.rootPart.Velocity = Vector3.new()
    end
end

-- ========== ANIM PLAYER WITH ROOT MOVEMENT SUPPORT ==========
local AnimPlayer = {}
AnimPlayer.__index = AnimPlayer

function AnimPlayer.new(rig, kfs)
    local self = setmetatable({}, AnimPlayer)
    self.rig = rig
    self.seq, self.looped = ConvertToTable(kfs)
    self.map, self.lower, self.partToMotor, self.motorToPart = BuildMotorMap(rig)
    self.time, self.playing = 0, false
    self.length = self.seq[#self.seq].Time
    self.speed = 1
    self.isR15 = IsR15(rig)
    self.savedC0 = {}
    
    -- Debug output
    warn("[Animator6D] ===== MOTOR DETECTION =====")
    warn("[Animator6D] Model:", rig.Name)
    warn("[Animator6D] Rig type:", self.isR15 and "R15" or "R6")
    warn("[Animator6D] Key motors found:")
    
    local keyMotors = {"Root", "Waist", "Neck", "LeftShoulder", "RightShoulder", "LeftHip", "RightHip"}
    for _, motorName in ipairs(keyMotors) do
        if self.map[motorName] then
            local partName = self.motorToPart[self.map[motorName]] or "Unknown"
            warn("[Animator6D]   " .. motorName .. " -> " .. partName)
        end
    end
    
    -- Initialize root movement controller
    if humanoidRootPart then
        self.rootMovement = RootMovement.new(humanoidRootPart, self.isR15)
    end
    
    -- Save original C0 values
    for _, m in pairs(self.map) do
        if m:IsA("Motor6D") then
            self.savedC0[m] = m.C0
        end
    end
    
    return self
end

function AnimPlayer:Play(speed, loop)
    if self.playing then return end
    self.playing, self.speed = true, speed or 1
    self.looped = (loop == nil) and true or loop
    
    -- Reset root movement
    if self.rootMovement then
        self.rootMovement:Reset()
    end
    
    -- Store start time
    self.startTime = tick()
    self.lastFrameTime = tick()

    self.conn = RunService.Heartbeat:Connect(function(dt)
        if not self.playing then return end
        
        local currentTime = tick()
        local frameDelta = currentTime - self.lastFrameTime
        self.lastFrameTime = currentTime
        
        self.time += dt * self.speed

        if self.time > self.length then
            if self.looped then
                self.time = self.time % self.length
                if self.rootMovement then
                    self.rootMovement:Reset()
                end
            else
                self:Stop(true)
                return
            end
        end

        -- Find current keyframe
        local currentFrame = self.seq[1]
        local nextFrame = self.seq[1]
        
        for i = 1, #self.seq do
            if self.seq[i].Time <= self.time then
                currentFrame = self.seq[i]
            else
                nextFrame = self.seq[i]
                break
            end
        end

        -- Track root movement
        local hasRootMovement = false
        local rootCFrame = nil
        local rootPoseName = nil

        -- Apply poses
        for joint, data in pairs(currentFrame.Data) do
            local motor = FindMotor(joint, self.map, self.lower, self.isR15)
            if motor then
                pcall(function()
                    if data.IsRoot then
                        hasRootMovement = true
                        rootCFrame = data.CFrame
                        rootPoseName = joint
                        
                        -- Apply to motor with correction
                        motor.C0 = ApplyR15Correction(motor, self.savedC0[motor], data.CFrame, joint, self.isR15)
                    else
                        -- Regular pose
                        motor.C0 = ApplyR15Correction(motor, self.savedC0[motor], data.CFrame, joint, self.isR15)
                    end
                end)
            end
        end
        
        -- Apply root movement if detected
        if hasRootMovement and rootCFrame and self.rootMovement then
            self.rootMovement:ApplyMovement(rootCFrame, frameDelta)
        end
    end)
end

function AnimPlayer:Stop(restore)
    self.playing = false
    if self.conn then 
        self.conn:Disconnect() 
        self.conn = nil 
    end
    
    -- Stop root movement
    if self.rootMovement then
        self.rootMovement:Reset()
    end
    
    if restore then
        -- Restore original poses
        for motor, origC0 in pairs(self.savedC0) do
            pcall(function() 
                motor.C0 = origC0 
            end)
        end
    else
        -- Reset transforms
        for _, m in pairs(self.map) do
            if m:IsA("Motor6D") then
                pcall(function() 
                    m.Transform = CFrame.new() 
                end)
            end
        end
    end
end

-- ========== DISABLE DEFAULT ANIMATIONS ==========
local function disableDefaultAnimations(model)
    if not model then return end
    
    local modelHum = model:FindFirstChildOfClass("Humanoid")
    if modelHum then
        for _, track in ipairs(modelHum:GetPlayingAnimationTracks()) do
            track:Stop(0)
        end
        
        local animScript = model:FindFirstChild("Animate")
        if animScript then animScript.Disabled = true end
        
        local animator = modelHum:FindFirstChildOfClass("Animator")
        if animator then animator:Destroy() end
    end
end

-- ========== MODEL MANAGEMENT ==========
local function RefreshCharacter()
    UpdateCharacter()
    
    -- Restart current animation if playing
    if getgenv().currentAnimator6D and getgenv().currentAnimator6D.playing then
        local currentAnim = getgenv().currentAnimator6D
        local animId = currentAnim.animId
        local speed = currentAnim.speed
        local looped = currentAnim.looped
        
        currentAnim:Stop(false)
        
        if animId then
            task.wait(0.2) -- Allow model to settle
            getgenv().Animator6D(animId, speed, looped)
        end
    end
end

-- ========== GLOBAL INTERFACE ==========
getgenv().Animator6D = function(idOrInstance, speed, looped)
    -- Auto-refresh character
    RefreshCharacter()
    
    if not character then
        warn("[Animator6D] No character/model available")
        return
    end
    
    local kfs
    if typeof(idOrInstance) == "Instance" then
        kfs = idOrInstance:IsA("KeyframeSequence") and idOrInstance or idOrInstance:FindFirstChildOfClass("KeyframeSequence")
    else
        local asset = LoadLocalAsset(idOrInstance)
        if asset then
            kfs = asset:FindFirstChildOfClass("KeyframeSequence") or asset
        end
    end

    if not kfs then
        warn("[Animator6D] Could not load animation:", idOrInstance)
        return
    end

    disableDefaultAnimations(character)

    if getgenv().currentAnimator6D then
        pcall(function()
            getgenv().currentAnimator6D:Stop(true)
        end)
    end

    local anim = AnimPlayer.new(character, kfs)
    getgenv().currentAnimator6D = anim
    anim.animId = typeof(idOrInstance) == "number" and idOrInstance or nil
    anim.speed = speed or 1
    anim.looped = looped
    anim:Play(speed or 1, looped)
    
    warn("[Animator6D] âœ“ Playing animation on " .. currentModelType)
end

getgenv().Animator6DStop = function()
    if getgenv().currentAnimator6D then
        pcall(function() 
            getgenv().currentAnimator6D:Stop(true) 
        end)
        getgenv().currentAnimator6D = nil
        warn("[Animator6D] âœ“ Animation stopped")
    end
end

getgenv().Animator6DRefresh = function()
    RefreshCharacter()
    warn("[Animator6D] âœ“ Model refreshed")
end

getgenv().Animator6DUseCustom = function(model)
    if model and model:IsA("Model") then
        character = model
        hum = character:FindFirstChildOfClass("Humanoid")
        humanoidRootPart = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
        currentModelType = "Manual: " .. model.Name
        warn("[Animator6D] âœ“ Using custom model:", model.Name)
    end
end

getgenv().Animator6DUsePlayer = function()
    character = player.Character or player.CharacterAdded:Wait()
    hum = character:WaitForChild("Humanoid")
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    currentModelType = "Player Character"
    warn("[Animator6D] âœ“ Using player character")
end

-- ========== AUTO-REFRESH SYSTEM ==========
-- Listen for character changes
player.CharacterAdded:Connect(function(char)
    task.wait(0.5)
    RefreshCharacter()
end)

-- Periodic model check
spawn(function()
    while true do
        task.wait(3)
        
        -- Check if current model still exists
        if character and not character.Parent then
            warn("[Animator6D] Current model removed, refreshing...")
            RefreshCharacter()
        end
        
        -- Check for better models
        local bestModel = FindAvailableModel()
        if bestModel and bestModel ~= character then
            warn("[Animator6D] Better model available, refreshing...")
            RefreshCharacter()
        end
    end
end)

-- ========== INITIAL NOTIFICATION ==========
warn("\n" .. string.rep("=", 50))
warn("          ANIMATOR6D PRO V5 (ULTIMATE)")
warn(string.rep("=", 50))
warn("Features:")
warn("âœ“ Auto-detects ANY model (player, O49_R, workspace)")
warn("âœ“ Universal R6/R15 support with smart detection")
warn("âœ“ Custom model support (Glamrock Freddy, etc.)")
warn("âœ“ Root movement with R15 forward correction")
warn("âœ“ Local cache for 403 evasion")
warn("âœ“ Arms/head preserved (minimal R15 correction)")
warn("âœ“ Auto-refresh on model changes")
warn(string.rep("=", 50) .. "\n")

pcall(function()
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Animator6D Pro V5",
        Text = "ULTIMATE VERSION LOADED!",
        Duration = 5,
        Icon = "rbxassetid://0"
    })
end)

--
--[[
====================================================================
                    ANIMATOR6D PRO V5 - ULTIMATE GUIDE
====================================================================

AUTOMATIC MODE (Recommended):
- Script automatically finds the best available model
- Priority: Player custom model > Player character > O49_R > Workspace
- Just call: getgenv().Animator6D(ANIMATION_ID, 1, true)

MANUAL CONTROL:
1. Force use player character:
   getgenv().Animator6DUsePlayer()
   
2. Force use specific model:
   getgenv().Animator6DUseCustom(workspace.YourModel)

3. Refresh model detection:
   getgenv().Animator6DRefresh()

USAGE:
1. Play animation:
   getgenv().Animator6D(1234567890, 1, true) -- ID, Speed, Looped
   
2. Play with instance:
   local anim = game:GetObjects("rbxassetid://ID")[1]
   getgenv().Animator6D(anim, 1, true)

3. Stop animation:
   getgenv().Animator6DStop()

SUPPORTED MODELS:
- Player R6/R15 characters
- Player custom models (equipped costumes)
- Models in workspace.O49_R folder  
- Any workspace model with Motor6Ds
- Your Glamrock Freddy and similar custom rigs

====================================================================
--]]

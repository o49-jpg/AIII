--//====================================================\\--
--||           Animator6D Pro V5 (Universal)           ||--
--||  Author: gObl00x + GPT-5 + R15 Adaptation        ||--
--||  Features: R6/R15 auto-detection, universal rig   ||--
--\\====================================================//--

if getgenv().Animator6DLoadedPro then return end
getgenv().Animator6DLoadedPro = true

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hum = character:WaitForChild("Humanoid")

-- ========== RIG TYPE DETECTION ==========
local function GetRigType()
    if hum.RigType == Enum.HumanoidRigType.R6 then
        return "R6"
    elseif hum.RigType == Enum.HumanoidRigType.R15 then
        return "R15"
    end
    -- Fallback detection
    if character:FindFirstChild("UpperTorso") then
        return "R15"
    else
        return "R6"
    end
end

local RIG_TYPE = GetRigType()
warn("[Animator6D] Detected rig type:", RIG_TYPE)

-- ========== LOCAL CACHE / 403 EVASION ==========
local LocalAssetCache = {}
local fullModel = nil
pcall(function()
    fullModel = game:GetObjects("rbxassetid://107495486817639")[1]
    if fullModel then
        fullModel.Parent = workspace
    end
end)

local function LoadLocalAsset(id)
    id = tostring(id):gsub("^rbxassetid://", "")
    if LocalAssetCache[id] then
        return LocalAssetCache[id]
    end

    local found = fullModel and fullModel:FindFirstChild(id, true)
    if found then
        LocalAssetCache[id] = found
        warn("[Animator6D] ✅ Loaded from local cache:", id)
        return found
    end

    local ok, obj = pcall(function()
        return game:GetObjects("rbxassetid://" .. id)[1]
    end)
    if ok and obj then
        LocalAssetCache[id] = obj
        warn("[Animator6D] ✅ Loaded via GetObjects:", id)
        return obj
    end

    warn("[Animator6D] Failed to load animation:", id)
    return nil
end
-- ===============================================

-- ========== JOINT MAPPING (R6 & R15) ==========
local R6JointMap = {
    ["Head"] = "Neck",
    ["Torso"] = "RootJoint",
    ["Right Arm"] = "Right Shoulder",
    ["Left Arm"] = "Left Shoulder",
    ["Right Leg"] = "Right Hip",
    ["Left Leg"] = "Left Hip"
}

local R15JointMap = {
    -- Head/Neck
    ["Head"] = "Neck",
    
    -- Torso/Spine
    ["UpperTorso"] = "Waist",
    ["LowerTorso"] = "RootJoint",
    
    -- Arms
    ["RightUpperArm"] = "RightShoulder",
    ["RightLowerArm"] = "RightElbow",
    ["RightHand"] = "RightWrist",
    
    ["LeftUpperArm"] = "LeftShoulder",
    ["LeftLowerArm"] = "LeftElbow",
    ["LeftHand"] = "LeftWrist",
    
    -- Legs
    ["RightUpperLeg"] = "RightHip",
    ["RightLowerLeg"] = "RightKnee",
    ["RightFoot"] = "RightAnkle",
    
    ["LeftUpperLeg"] = "LeftHip",
    ["LeftLowerLeg"] = "LeftKnee",
    ["LeftFoot"] = "LeftAnkle"
}

-- Special handling for R15 accessories
local R15AccessoryMap = {
    ["Hat"] = "HatAttachment",
    ["Hair"] = "HairAttachment",
    ["Face"] = "FaceFrontAttachment"
}

local function GetJointMap()
    return RIG_TYPE == "R6" and R6JointMap or R15JointMap
end

-- ========== KEYFRAME PARSER ==========
local function ConvertToTable(kfs)
    if not (kfs and typeof(kfs) == "Instance" and kfs:IsA("KeyframeSequence")) then
        if typeof(kfs) == "Instance" then
            for _, obj in ipairs(kfs:GetDescendants()) do
                if obj:IsA("KeyframeSequence") then
                    kfs = obj
                    break
                end
            end
        end
    end

    assert(kfs and typeof(kfs) == "Instance" and kfs:IsA("KeyframeSequence"), "Expected KeyframeSequence")

    local seq = {}
    for _, frame in ipairs(kfs:GetKeyframes()) do
        local entry = { Time = frame.Time, Data = {} }
        for _, pose in ipairs(frame:GetDescendants()) do
            if pose:IsA("Pose") and pose.Weight > 0 then
                -- Handle both regular poses and accessory poses
                local poseName = pose.Name
                if pose:IsA("AttachmentPose") then
                    -- For R15 accessory poses, map to the correct attachment
                    if R15AccessoryMap[poseName] then
                        poseName = R15AccessoryMap[poseName]
                    end
                end
                entry.Data[poseName] = { CFrame = pose.CFrame }
            end
        end
        table.insert(seq, entry)
    end
    table.sort(seq, function(a, b) return a.Time < b.Time end)
    return seq, kfs.Loop
end

-- ========== MOTOR MAP ==========
local function BuildMotorMap(rig)
    local map, lower, allMotors = {}, {}, {}
    
    -- Collect all Motor6D joints
    for _, m in ipairs(rig:GetDescendants()) do
        if m:IsA("Motor6D") then
            map[m.Name] = m
            lower[string.lower(m.Name)] = m
            table.insert(allMotors, m)
        end
    end
    
    -- For R15, also handle accessories and their attachments
    if RIG_TYPE == "R15" then
        for _, accessory in ipairs(rig:GetDescendants()) do
            if accessory:IsA("Accessory") then
                local handle = accessory:FindFirstChild("Handle")
                if handle then
                    for _, attachment in ipairs(handle:GetDescendants()) do
                        if attachment:IsA("Attachment") then
                            map[attachment.Name] = attachment
                            lower[string.lower(attachment.Name)] = attachment
                        end
                    end
                end
            end
        end
    end
    
    return map, lower, allMotors
end

local function FindMotor(poseName, map, lower)
    local jointMap = GetJointMap()
    local match = jointMap[poseName] or poseName
    
    -- Try direct map first
    local motor = map[match] or lower[string.lower(match)]
    
    -- If not found, try some common variations
    if not motor and RIG_TYPE == "R15" then
        -- Handle R15 part name variations
        local variations = {
            [poseName .. "RigAttachment"] = poseName,
            [poseName .. "Attachment"] = poseName,
            [poseName:gsub(" ", "")] = poseName
        }
        
        for variation in pairs(variations) do
            motor = map[variation] or lower[string.lower(variation)]
            if motor then break end
        end
    end
    
    return motor
end

-- ========== ANIM PLAYER ==========
local AnimPlayer = {}
AnimPlayer.__index = AnimPlayer

function AnimPlayer.new(rig, kfs)
    local self = setmetatable({}, AnimPlayer)
    self.rig = rig
    self.seq, self.looped = ConvertToTable(kfs)
    self.map, self.lower, self.allMotors = BuildMotorMap(rig)
    self.time, self.playing = 0, false
    self.length = self.seq[#self.seq].Time
    self.speed = 1
    self.savedC0 = {}
    self.savedTransforms = {}
    
    -- Save original transforms for all motors
    for _, motor in ipairs(self.allMotors) do
        self.savedC0[motor] = motor.C0
        self.savedTransforms[motor] = motor.Transform
    end
    
    return self
end

function AnimPlayer:Play(speed, loop)
    if self.playing then return end
    self.playing, self.speed = true, speed or 1
    self.looped = (loop == nil) and true or loop

    self.conn = RunService.Heartbeat:Connect(function(dt)
        if not self.playing then return end
        self.time += dt * self.speed

        if self.time > self.length then
            if self.looped then
                self.time -= self.length
            else
                self:Stop(true)
                return
            end
        end

        -- Find current keyframe
        local currentFrame = self.seq[1]
        for i = 1, #self.seq do
            if self.seq[i].Time <= self.time then
                currentFrame = self.seq[i]
            else
                break
            end
        end

        -- Apply poses
        for joint, data in pairs(currentFrame.Data) do
            local motor = FindMotor(joint, self.map, self.lower)
            if motor then
                pcall(function()
                    if motor:IsA("Motor6D") then
                        motor.C0 = self.savedC0[motor] * data.CFrame
                    elseif motor:IsA("Attachment") and RIG_TYPE == "R15" then
                        -- Handle R15 accessory attachments
                        motor.WorldCFrame = data.CFrame
                    end
                end)
            end
        end
    end)
end

function AnimPlayer:Stop(restore)
    self.playing = false
    if self.conn then self.conn:Disconnect() self.conn = nil end
    
    if restore then
        -- Restore original C0 values
        for motor, origC0 in pairs(self.savedC0) do
            pcall(function() 
                if motor:IsA("Motor6D") then
                    motor.C0 = origC0 
                end
            end)
        end
    else
        -- Reset transforms to identity
        for motor, origTransform in pairs(self.savedTransforms) do
            pcall(function() 
                if motor:IsA("Motor6D") then
                    motor.Transform = CFrame.new() 
                end
            end)
        end
    end
end

-- ========== DISABLE DEFAULT ANIMS ==========
local function disableDefaultAnimations(char)
    if not hum then return end
    for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
        track:Stop(0)
    end
    local animScript = char:FindFirstChild("Animate")
    if animScript then animScript.Disabled = true end
    local animator = hum:FindFirstChildOfClass("Animator")
    if animator then animator:Destroy() end
end

-- ========== CHARACTER REINIT ON RESPAWN ==========
player.CharacterAdded:Connect(function(newChar)
    character = newChar
    hum = character:WaitForChild("Humanoid")
    RIG_TYPE = GetRigType()
    warn("[Animator6D] Character respawned, rig type:", RIG_TYPE)
end)

-- ========== GLOBAL INTERFACE ==========
getgenv().Animator6D = function(idOrInstance, speed, looped)
    local kfs
    if typeof(idOrInstance) == "Instance" then
        kfs = idOrInstance:IsA("KeyframeSequence") and idOrInstance or idOrInstance:FindFirstChildOfClass("KeyframeSequence")
    else
        local asset = LoadLocalAsset(idOrInstance)
        if asset then
            kfs = asset:FindFirstChildOfClass("KeyframeSequence") or asset
        end
    end

    if not kfs then
        warn("[Animator6D] Could not load animation:", idOrInstance)
        return
    end

    disableDefaultAnimations(character)

    if getgenv().currentAnimator6D then
        pcall(function()
            getgenv().currentAnimator6D:Stop(true)
        end)
    end

    local anim = AnimPlayer.new(character, kfs)
    getgenv().currentAnimator6D = anim
    anim:Play(speed or 1, looped)
end

getgenv().Animator6DStop = function()
    if getgenv().currentAnimator6D then
        pcall(function() getgenv().currentAnimator6D:Stop(true) end)
        getgenv().currentAnimator6D = nil
    end
end

-- ========== UTILITY FUNCTIONS ==========
getgenv().Animator6DGetRigType = function()
    return RIG_TYPE
end

getgenv().Animator6DSetSpeed = function(speed)
    if getgenv().currentAnimator6D then
        getgenv().currentAnimator6D.speed = speed or 1
    end
end

-- ========== NOTIFY ==========
warn("[Animator6D Pro V5] Universal R6/R15 Loaded!")
pcall(function()
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Animator6D Pro V5",
        Text = "Universal R6/R15 Support Enabled!",
        Duration = 5
    })
end)

--[[
USAGE:
-- Play animation by ID
getgenv().Animator6D(1234567890, 1, true)

-- Play animation by instance
local anim = game:GetObjects("rbxassetid://ID")[1]
getgenv().Animator6D(anim, 1, true)

-- Stop animation
getgenv().Animator6DStop()

-- Get current rig type
print(getgenv().Animator6DGetRigType())

-- Change animation speed
getgenv().Animator6DSetSpeed(2)
]]

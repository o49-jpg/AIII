--//====================================================\\--
--||           Animator6D Pro V6 (Universal)           ||--
--||  Features: R6/R15 auto-detection + Trim Support   ||--
--\\====================================================//--

if getgenv().Animator6DLoadedPro then return end
getgenv().Animator6DLoadedPro = true

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hum = character:WaitForChild("Humanoid")

-- ========== RIG TYPE DETECTION ==========
local function GetRigType()
    if hum.RigType == Enum.HumanoidRigType.R6 then
        return "R6"
    elseif hum.RigType == Enum.HumanoidRigType.R15 then
        return "R15"
    end
    if character:FindFirstChild("UpperTorso") then
        return "R15"
    else
        return "R6"
    end
end

local RIG_TYPE = GetRigType()
warn("[Animator6D] Detected rig type:", RIG_TYPE)

-- ========== LOCAL CACHE / 403 EVASION ==========
local LocalAssetCache = {}
local fullModel = nil
pcall(function()
    fullModel = game:GetObjects("rbxassetid://107495486817639")[1]
    if fullModel then
        fullModel.Parent = workspace
    end
end)

local function LoadLocalAsset(id)
    id = tostring(id):gsub("^rbxassetid://", "")
    if LocalAssetCache[id] then
        return LocalAssetCache[id]
    end

    local found = fullModel and fullModel:FindFirstChild(id, true)
    if found then
        LocalAssetCache[id] = found
        warn("[Animator6D] ✅ Loaded from local cache:", id)
        return found
    end

    local ok, obj = pcall(function()
        return game:GetObjects("rbxassetid://" .. id)[1]
    end)
    if ok and obj then
        LocalAssetCache[id] = obj
        warn("[Animator6D] ✅ Loaded via GetObjects:", id)
        return obj
    end

    warn("[Animator6D] Failed to load animation:", id)
    return nil
end
-- ===============================================

-- ========== KEYFRAME PARSER ==========
local function ConvertToTable(kfs, startTime, endTime)
    if not (kfs and typeof(kfs) == "Instance" and kfs:IsA("KeyframeSequence")) then
        if typeof(kfs) == "Instance" then
            for _, obj in ipairs(kfs:GetDescendants()) do
                if obj:IsA("KeyframeSequence") then
                    kfs = obj
                    break
                end
            end
        end
    end

    assert(kfs and typeof(kfs) == "Instance" and kfs:IsA("KeyframeSequence"), "Expected KeyframeSequence")

    local seq = {}
    local frames = kfs:GetKeyframes()
    
    -- Apply trimming if startTime/endTime provided
    for _, frame in ipairs(frames) do
        -- Skip frames outside trim range
        if startTime and frame.Time < startTime then
            continue
        end
        if endTime and frame.Time > endTime then
            continue
        end
        
        local entry = { 
            Time = frame.Time,
            OriginalTime = frame.Time,
            Data = {} 
        }
        
        -- Adjust time if startTime is specified
        if startTime then
            entry.Time = frame.Time - startTime
        end
        
        for _, pose in ipairs(frame:GetDescendants()) do
            if pose:IsA("Pose") and pose.Weight > 0 then
                entry.Data[pose.Name] = { CFrame = pose.CFrame }
            end
        end
        table.insert(seq, entry)
    end
    
    -- If trimmed and no frames at time 0, add a dummy frame
    if startTime and startTime > 0 and (#seq == 0 or seq[1].Time > 0) then
        table.insert(seq, 1, { Time = 0, Data = {}, OriginalTime = startTime })
    end
    
    table.sort(seq, function(a, b) return a.Time < b.Time end)
    return seq, kfs.Loop
end

-- ========== TRIM UTILITY FUNCTIONS ==========
local function CreateTrimmedKeyframeSequence(kfs, startTime, endTime)
    -- Creates a new KeyframeSequence with only frames between startTime and endTime
    local newKfs = Instance.new("KeyframeSequence")
    newKfs.Name = "Trimmed_" .. kfs.Name
    newKfs.Priority = kfs.Priority
    newKfs.Loop = kfs.Loop
    
    local frames = kfs:GetKeyframes()
    for _, frame in ipairs(frames) do
        if frame.Time >= startTime and frame.Time <= endTime then
            local newFrame = frame:Clone()
            newFrame.Time = frame.Time - startTime  -- Normalize to start at 0
            newFrame.Parent = newKfs
        end
    end
    
    -- Ensure we have at least one frame
    if #newKfs:GetChildren() == 0 then
        local dummyFrame = Instance.new("Keyframe")
        dummyFrame.Time = 0
        dummyFrame.Parent = newKfs
    end
    
    return newKfs
end

local function AnalyzeAnimation(kfs)
    -- Returns information about the animation for debugging
    local frames = kfs:GetKeyframes()
    local info = {
        frameCount = #frames,
        totalDuration = frames[#frames] and frames[#frames].Time or 0,
        frames = {}
    }
    
    for i, frame in ipairs(frames) do
        local poseCount = 0
        for _ in pairs(frame.Data or {}) do poseCount = poseCount + 1 end
        
        table.insert(info.frames, {
            time = frame.Time,
            poseCount = poseCount,
            hasPoses = poseCount > 0
        })
    end
    
    return info
end

-- ========== MOTOR MAP ==========
local R6JointMap = {
    ["Head"] = "Neck",
    ["Torso"] = "RootJoint",
    ["Right Arm"] = "Right Shoulder",
    ["Left Arm"] = "Left Shoulder",
    ["Right Leg"] = "Right Hip",
    ["Left Leg"] = "Left Hip"
}

local R15JointMap = {
    ["Head"] = "Neck",
    ["UpperTorso"] = "Waist",
    ["LowerTorso"] = "RootJoint",
    ["RightUpperArm"] = "RightShoulder",
    ["RightLowerArm"] = "RightElbow",
    ["RightHand"] = "RightWrist",
    ["LeftUpperArm"] = "LeftShoulder",
    ["LeftLowerArm"] = "LeftElbow",
    ["LeftHand"] = "LeftWrist",
    ["RightUpperLeg"] = "RightHip",
    ["RightLowerLeg"] = "RightKnee",
    ["RightFoot"] = "RightAnkle",
    ["LeftUpperLeg"] = "LeftHip",
    ["LeftLowerLeg"] = "LeftKnee",
    ["LeftFoot"] = "LeftAnkle"
}

local function BuildMotorMap(rig)
    local map, lower, allMotors = {}, {}, {}
    
    for _, m in ipairs(rig:GetDescendants()) do
        if m:IsA("Motor6D") then
            map[m.Name] = m
            lower[string.lower(m.Name)] = m
            table.insert(allMotors, m)
        end
    end
    
    if RIG_TYPE == "R15" then
        for _, accessory in ipairs(rig:GetDescendants()) do
            if accessory:IsA("Accessory") then
                local handle = accessory:FindFirstChild("Handle")
                if handle then
                    for _, attachment in ipairs(handle:GetDescendants()) do
                        if attachment:IsA("Attachment") then
                            map[attachment.Name] = attachment
                            lower[string.lower(attachment.Name)] = attachment
                        end
                    end
                end
            end
        end
    end
    
    return map, lower, allMotors
end

local function FindMotor(poseName, map, lower)
    local jointMap = RIG_TYPE == "R6" and R6JointMap or R15JointMap
    local match = jointMap[poseName] or poseName
    
    local motor = map[match] or lower[string.lower(match)]
    
    if not motor and RIG_TYPE == "R15" then
        local variations = {
            [poseName .. "RigAttachment"] = poseName,
            [poseName .. "Attachment"] = poseName,
            [poseName:gsub(" ", "")] = poseName
        }
        
        for variation in pairs(variations) do
            motor = map[variation] or lower[string.lower(variation)]
            if motor then break end
        end
    end
    
    return motor
end

-- ========== ANIM PLAYER ==========
local AnimPlayer = {}
AnimPlayer.__index = AnimPlayer

function AnimPlayer.new(rig, kfs, startTime, endTime)
    local self = setmetatable({}, AnimPlayer)
    self.rig = rig
    self.seq, self.looped = ConvertToTable(kfs, startTime, endTime)
    self.map, self.lower, self.allMotors = BuildMotorMap(rig)
    self.time, self.playing = 0, false
    self.length = self.seq[#self.seq] and self.seq[#self.seq].Time or 0
    self.speed = 1
    self.savedC0 = {}
    self.savedTransforms = {}
    self.trimStart = startTime or 0
    self.trimEnd = endTime
    
    for _, motor in ipairs(self.allMotors) do
        self.savedC0[motor] = motor.C0
        self.savedTransforms[motor] = motor.Transform
    end
    
    return self
end

function AnimPlayer:Play(speed, loop)
    if self.playing then return end
    self.playing, self.speed = true, speed or 1
    self.looped = (loop == nil) and true or loop

    self.conn = RunService.Heartbeat:Connect(function(dt)
        if not self.playing then return end
        self.time = self.time + (dt * self.speed)

        if self.time > self.length then
            if self.looped then
                self.time = self.time - self.length
            else
                self:Stop(true)
                return
            end
        end

        local prev = self.seq[1]
        for i = 1, #self.seq do
            if self.seq[i].Time <= self.time then
                prev = self.seq[i]
            else
                break
            end
        end

        for joint, data in pairs(prev.Data) do
            local motor = FindMotor(joint, self.map, self.lower)
            if motor then
                pcall(function()
                    if motor:IsA("Motor6D") then
                        motor.C0 = self.savedC0[motor] * data.CFrame
                    elseif motor:IsA("Attachment") and RIG_TYPE == "R15" then
                        motor.WorldCFrame = data.CFrame
                    end
                end)
            end
        end
    end)
end

function AnimPlayer:Stop(restore)
    self.playing = false
    if self.conn then self.conn:Disconnect() self.conn = nil end
    
    if restore then
        for motor, origC0 in pairs(self.savedC0) do
            pcall(function() 
                if motor:IsA("Motor6D") then
                    motor.C0 = origC0 
                end
            end)
        end
    else
        for motor, origTransform in pairs(self.savedTransforms) do
            pcall(function() 
                if motor:IsA("Motor6D") then
                    motor.Transform = CFrame.new() 
                end
            end)
        end
    end
end

-- ========== DISABLE DEFAULT ANIMS ==========
local function disableDefaultAnimations(char)
    if not hum then return end
    for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
        track:Stop(0)
    end
    local animScript = char:FindFirstChild("Animate")
    if animScript then animScript.Disabled = true end
    local animator = hum:FindFirstChildOfClass("Animator")
    if animator then animator:Destroy() end
end

-- ========== GLOBAL INTERFACE WITH TRIM SUPPORT ==========
getgenv().Animator6D = function(idOrInstance, speed, looped, startTime, endTime)
    local kfs
    if typeof(idOrInstance) == "Instance" then
        kfs = idOrInstance:IsA("KeyframeSequence") and idOrInstance or idOrInstance:FindFirstChildOfClass("KeyframeSequence")
    else
        local asset = LoadLocalAsset(idOrInstance)
        if asset then
            kfs = asset:FindFirstChildOfClass("KeyframeSequence") or asset
        end
    end

    if not kfs then
        warn("[Animator6D] Could not load animation:", idOrInstance)
        return
    end

    -- Debug info for trimming
    if startTime or endTime then
        local frames = kfs:GetKeyframes()
        local totalTime = frames[#frames] and frames[#frames].Time or 0
        warn(string.format("[Animator6D] Trimming: %.2fs to %.2fs (total: %.2fs)", 
            startTime or 0, endTime or totalTime, totalTime))
    end

    disableDefaultAnimations(character)

    if getgenv().currentAnimator6D then
        pcall(function()
            getgenv().currentAnimator6D:Stop(true)
        end)
    end

    local anim = AnimPlayer.new(character, kfs, startTime, endTime)
    getgenv().currentAnimator6D = anim
    anim:Play(speed or 1, looped)
    
    return anim
end

-- NEW: Trim-specific function
getgenv().Animator6DTrim = function(idOrInstance, startTime, endTime, speed, looped)
    return getgenv().Animator6D(idOrInstance, speed or 1, looped == nil and true or looped, startTime, endTime)
end

-- NEW: Animation analyzer
getgenv().Animator6DAnalyze = function(idOrInstance)
    local kfs
    if typeof(idOrInstance) == "Instance" then
        kfs = idOrInstance:IsA("KeyframeSequence") and idOrInstance or idOrInstance:FindFirstChildOfClass("KeyframeSequence")
    else
        local asset = LoadLocalAsset(idOrInstance)
        if asset then
            kfs = asset:FindFirstChildOfClass("KeyframeSequence") or asset
        end
    end
    
    if not kfs then
        warn("[Animator6D] Could not load animation for analysis")
        return
    end
    
    local info = AnalyzeAnimation(kfs)
    
    print("=== Animation Analysis ===")
    print("Total frames:", info.frameCount)
    print("Total duration:", info.totalDuration .. "s")
    print("\nFrame breakdown:")
    
    for i, frame in ipairs(info.frames) do
        print(string.format("  Frame %d: %.3fs - %d poses", i, frame.time, frame.poseCount))
    end
    
    -- Find gaps (potential branch points)
    local gaps = {}
    for i = 2, #info.frames do
        local gap = info.frames[i].time - info.frames[i-1].time
        if gap > 0.5 then  -- Gaps larger than 0.5 seconds
            table.insert(gaps, {
                from = info.frames[i-1].time,
                to = info.frames[i].time,
                duration = gap
            })
        end
    end
    
    if #gaps > 0 then
        print("\nPotential branch points (gaps > 0.5s):")
        for i, gap in ipairs(gaps) do
            print(string.format("  Gap %d: %.3fs to %.3fs (%.3fs gap)", i, gap.from, gap.to, gap.duration))
        end
    end
    
    return info
end

getgenv().Animator6DStop = function()
    if getgenv().currentAnimator6D then
        pcall(function() getgenv().currentAnimator6D:Stop(true) end)
        getgenv().currentAnimator6D = nil
    end
end

-- ========== CHARACTER REINIT ==========
player.CharacterAdded:Connect(function(newChar)
    character = newChar
    hum = character:WaitForChild("Humanoid")
    RIG_TYPE = GetRigType()
    warn("[Animator6D] Character respawned, rig type:", RIG_TYPE)
end)

-- ========== NOTIFY ==========
warn("[Animator6D Pro V6] Loaded with Trim Support!")
pcall(function()
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Animator6D Pro V6",
        Text = "Loaded with Animation Trimming!",
        Duration = 5
    })
end)

--[[
USAGE WITH TRIMMING:

-- Regular animation
getgenv().Animator6D(1234567890, 1, true)

-- Trimmed animation (0.5s to 3.5s)
getgenv().Animator6DTrim(1234567890, 0.5, 3.5, 1, true)

-- Or using extended parameters
getgenv().Animator6D(1234567890, 1, true, 0.5, 3.5)

-- Analyze an animation
getgenv().Animator6DAnalyze(1234567890)

-- Your specific animation with trimming
getgenv().Animator6DTrim(75190685223546, 0, 2.5, 1, false)  -- First part only
getgenv().Animator6DTrim(75190685223546, 2.5, 4.8, 1, false) -- Middle part
]]
